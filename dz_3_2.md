Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

1.	Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

Это встроенная команда Bash и меняет текущую папку только для оболочки, в которой выполняется. это вообще не утилита. Ее нет в файловой системе. Если бы эта команда была внешней утилитой, то каждый раз при ее выполнении командный интерпретатор должен был запуститься в новой текущей папке.



2.	Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l? man grep поможет в ответе на этот вопрос. Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.

vagrant@vagrant:~/my$ cat test.txt

qqweqw

23dfc qwqw1

1xasc

abcd

dscsc

vagrant@vagrant:~/my$ grep abcd test.txt -c

1

vagrant@vagrant:~/my$


3.	Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

pstree -p

systemd(1)─┬─VBoxService(849)─┬─{VBoxService}(851)

4.	Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?

who

vagrant  pts/0        2021-11-19 18:03 (10.0.2.2)

vagrant  pts/3        2021-11-20 09:52 (10.0.2.2)

sudo ls -l /blabla 2>/dev/pts/3

В pts/3 выходит ругачка "нет такого файла или каталога".

5.	Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.

vagrant@vagrant:~/temp$ cat temp.sh

#! /bin/bash

echo blabla

vagrant@vagrant:~/temp$ cat <temp.sh >temp_out

vagrant@vagrant:~/temp$ cat temp_out

#! /bin/bash

echo blabla

vagrant@vagrant:~/temp$


6.	Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

Получится.

echo Preved from pts0 to tty1 >/dev/tty1

На экране терминала TTY1 в виртуалке отобразится Preved from pts0


7.	Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?
	
bash 5>&1 - Создает дескриптор 5 и направит его в stdout

echo netology > /proc/$$/fd/5 - выведет netology в дескриптор 5, который перенаправлен в stdout



8.	Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

vagrant@vagrant:~$ ls -l /root 3>&2 2>&1 1>&3 |grep "Permission denied" -c 

1

3>&2 - новый дескриптор перенаправили в stderr

2>&1 - stderr перенаправили в stdout 

1>&3 - stdout - перенаправили в в новый дескриптор


9.	Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?

Выводятся переменные окружения:

аналогично только с разделением:

printenv

env

10.	Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.

man proc | grep -F '/proc/[pid]/cmdline' -n 

 man proc | grep -F '/proc/[pid]/exe' -n

/proc/<PID>/cmdline - путь до исполняемого файла процесса [PID] (строка 223)

 /proc/<PID>/exe - содержит ссылку к файлу запущенному для процесса [PID],(строка 276)

11.	Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.

grep sse /proc/cpuinfo

sse4a

12.	При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:
vagrant@netology1:~$ ssh localhost 'tty'
not a tty
Почитайте, почему так происходит, и как изменить поведение.

По умолчанию, когда вы запускаете команду на удаленном компьютере с помощью ssh, TTY не выделяется для удаленного сеанса. Это позволяет передавать двоичные данные и т. Д. Без необходимости работать с причудами TTY.

нужно :

 ssh -t localhost 'tty'

-t      Force pseudo-terminal allocation.  This can be used to execute
             arbitrary screen-based programs on a remote machine, which can be
             very useful, e.g. when implementing menu services.  Multiple -t
             options force tty allocation, even if ssh has no local tty.



13.	Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.

Иногда возникает необходимость перенести важный долго работающий процесс из консоли без screen в screen для последующего закрытия консоли. Этого можно достичь с помощью утилиты reptyr

файл /etc/sysctl.d/10-ptrace.conf - установить kernel.yama.ptrace_scope = 0 и перезагрузить ВМ

Сначала имеем две сессии

 vagrant@vagrant:~$ w
 
 10:52:07 up 4 min,  2 users,  load average: 0.13, 0.30, 0.17

 USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT

 vagrant  pts/0    10.0.2.2         10:48    0.00s  0.07s  0.01s w

 vagrant  pts/1    10.0.2.2         10:48    6.00s  0.03s  0.03s -bash

В первой запускаем top. Во второй видим 

 vagrant      914  1.0  0.3  11720  3544 pts/1    S+   10:53   0:00 top

 Делаем:

 reptyr -s 914

 top начал отображаться во второй сессии.

Хотя по такому пути Ping не получилось перетащить...

14.	sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. Для решения данной проблемы можно использовать конструкцию echo string | sudo tee /root/new_file. Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.

Shell запущен без sudo, а перенаправлением занимается он. 
Команда tee в Linux нужна для записи вывода любой команды в один или несколько файлов.
Поэтому если ее запустить с sudo через pipe вывод в файл выполнится.

